// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yamcs/protobuf/archive/parameter_archive_service.proto

package org.yamcs.protobuf;

public interface GetParameterRangesRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:yamcs.protobuf.archive.GetParameterRangesRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Yamcs instance name.
   * </pre>
   *
   * <code>optional string instance = 1;</code>
   * @return Whether the instance field is set.
   */
  boolean hasInstance();
  /**
   * <pre>
   * Yamcs instance name.
   * </pre>
   *
   * <code>optional string instance = 1;</code>
   * @return The instance.
   */
  java.lang.String getInstance();
  /**
   * <pre>
   * Yamcs instance name.
   * </pre>
   *
   * <code>optional string instance = 1;</code>
   * @return The bytes for instance.
   */
  com.google.protobuf.ByteString
      getInstanceBytes();

  /**
   * <pre>
   * Parameter name.
   * </pre>
   *
   * <code>optional string name = 2;</code>
   * @return Whether the name field is set.
   */
  boolean hasName();
  /**
   * <pre>
   * Parameter name.
   * </pre>
   *
   * <code>optional string name = 2;</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * Parameter name.
   * </pre>
   *
   * <code>optional string name = 2;</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * Filter the lower bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start = 3;</code>
   * @return Whether the start field is set.
   */
  boolean hasStart();
  /**
   * <pre>
   * Filter the lower bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start = 3;</code>
   * @return The start.
   */
  com.google.protobuf.Timestamp getStart();
  /**
   * <pre>
   * Filter the lower bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start = 3;</code>
   */
  com.google.protobuf.TimestampOrBuilder getStartOrBuilder();

  /**
   * <pre>
   * Filter the upper bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp stop = 4;</code>
   * @return Whether the stop field is set.
   */
  boolean hasStop();
  /**
   * <pre>
   * Filter the upper bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp stop = 4;</code>
   * @return The stop.
   */
  com.google.protobuf.Timestamp getStop();
  /**
   * <pre>
   * Filter the upper bound of the parameter's generation time. Specify a date
   * string in ISO 8601 format.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp stop = 4;</code>
   */
  com.google.protobuf.TimestampOrBuilder getStopOrBuilder();

  /**
   * <pre>
   * Time in milliseconds. Any gap (detected based on parameter expiration) smaller than
   * this will be ignored. However if the parameter changes value, the ranges will still
   * be split.
   * </pre>
   *
   * <code>optional int64 minGap = 5;</code>
   * @return Whether the minGap field is set.
   */
  boolean hasMinGap();
  /**
   * <pre>
   * Time in milliseconds. Any gap (detected based on parameter expiration) smaller than
   * this will be ignored. However if the parameter changes value, the ranges will still
   * be split.
   * </pre>
   *
   * <code>optional int64 minGap = 5;</code>
   * @return The minGap.
   */
  long getMinGap();

  /**
   * <pre>
   * Time in milliseconds. If the distance between two subsequent values of the parameter
   * is bigger than this value (but smaller than the parameter expiration), then an
   * artificial gap will be constructed. This also applies if there is no parameter
   * expiration defined for the parameter.
   * </pre>
   *
   * <code>optional int64 maxGap = 6;</code>
   * @return Whether the maxGap field is set.
   */
  boolean hasMaxGap();
  /**
   * <pre>
   * Time in milliseconds. If the distance between two subsequent values of the parameter
   * is bigger than this value (but smaller than the parameter expiration), then an
   * artificial gap will be constructed. This also applies if there is no parameter
   * expiration defined for the parameter.
   * </pre>
   *
   * <code>optional int64 maxGap = 6;</code>
   * @return The maxGap.
   */
  long getMaxGap();

  /**
   * <pre>
   * Disable loading of parameters from the parameter cache. Default: ``false``.
   * </pre>
   *
   * <code>optional bool norealtime = 7;</code>
   * @return Whether the norealtime field is set.
   */
  boolean hasNorealtime();
  /**
   * <pre>
   * Disable loading of parameters from the parameter cache. Default: ``false``.
   * </pre>
   *
   * <code>optional bool norealtime = 7;</code>
   * @return The norealtime.
   */
  boolean getNorealtime();

  /**
   * <pre>
   * The name of the processor from which to use the parameter cache. Default: ``realtime``.
   * </pre>
   *
   * <code>optional string processor = 8;</code>
   * @return Whether the processor field is set.
   */
  boolean hasProcessor();
  /**
   * <pre>
   * The name of the processor from which to use the parameter cache. Default: ``realtime``.
   * </pre>
   *
   * <code>optional string processor = 8;</code>
   * @return The processor.
   */
  java.lang.String getProcessor();
  /**
   * <pre>
   * The name of the processor from which to use the parameter cache. Default: ``realtime``.
   * </pre>
   *
   * <code>optional string processor = 8;</code>
   * @return The bytes for processor.
   */
  com.google.protobuf.ByteString
      getProcessorBytes();

  /**
   * <pre>
   * Specifies how to retrieve the parameters. Either ``ParameterArchive`` or
   * ``replay``. If ``replay`` is specified, a replay processor will be created
   * and data will be processed with the active Mission Database. Note that this
   * is much slower than receiving data from the ParameterArchive.
   * Default: ``ParameterArchive``.
   * </pre>
   *
   * <code>optional string source = 9;</code>
   * @return Whether the source field is set.
   */
  boolean hasSource();
  /**
   * <pre>
   * Specifies how to retrieve the parameters. Either ``ParameterArchive`` or
   * ``replay``. If ``replay`` is specified, a replay processor will be created
   * and data will be processed with the active Mission Database. Note that this
   * is much slower than receiving data from the ParameterArchive.
   * Default: ``ParameterArchive``.
   * </pre>
   *
   * <code>optional string source = 9;</code>
   * @return The source.
   */
  java.lang.String getSource();
  /**
   * <pre>
   * Specifies how to retrieve the parameters. Either ``ParameterArchive`` or
   * ``replay``. If ``replay`` is specified, a replay processor will be created
   * and data will be processed with the active Mission Database. Note that this
   * is much slower than receiving data from the ParameterArchive.
   * Default: ``ParameterArchive``.
   * </pre>
   *
   * <code>optional string source = 9;</code>
   * @return The bytes for source.
   */
  com.google.protobuf.ByteString
      getSourceBytes();

  /**
   * <pre>
   * Time in milliseconds of the minimum range to be returned. If the data changes more often,
   *a new range will not be created but the data will be added to the old range.
   * </pre>
   *
   * <code>optional int64 minRange = 10;</code>
   * @return Whether the minRange field is set.
   */
  boolean hasMinRange();
  /**
   * <pre>
   * Time in milliseconds of the minimum range to be returned. If the data changes more often,
   *a new range will not be created but the data will be added to the old range.
   * </pre>
   *
   * <code>optional int64 minRange = 10;</code>
   * @return The minRange.
   */
  long getMinRange();

  /**
   * <pre>
   * Maximum number of distinct values to be returned. The maximum number
   * applies across all ranges and is meant to limit the amount of data that
   * is being retrieved. The retrieved data has a count for each value as well
   * as a total count. The difference between the total count and the sum of the
   * individual counts can be used to compute the number of unsent values.
   * </pre>
   *
   * <code>optional int32 maxValues = 11;</code>
   * @return Whether the maxValues field is set.
   */
  boolean hasMaxValues();
  /**
   * <pre>
   * Maximum number of distinct values to be returned. The maximum number
   * applies across all ranges and is meant to limit the amount of data that
   * is being retrieved. The retrieved data has a count for each value as well
   * as a total count. The difference between the total count and the sum of the
   * individual counts can be used to compute the number of unsent values.
   * </pre>
   *
   * <code>optional int32 maxValues = 11;</code>
   * @return The maxValues.
   */
  int getMaxValues();
}
